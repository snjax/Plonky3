use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec;
use alloc::vec::Vec;
use core::fmt::Debug;
use core::marker::PhantomData;
use hashbrown::HashMap;
use itertools::zip_eq;
use p3_field::{ExtensionField, Field, PrimeField};
use crate::circuit_builder::{ExtensionTarget, Target, Wire};
use crate::circuit_builder::gate::ArithmeticGate;

/// A generator participates in the generation of the witness.
pub trait WitnessGenerator<F: PrimeField + ExtensionField<F>, const D: usize>:
'static + Send + Sync + Debug
{
    fn id(&self) -> String;

    /// Targets to be "watched" by this generator. Whenever a target in the watch list is populated,
    /// the generator will be queued to run.
    fn watch_list(&self) -> Vec<Target>;

    /// Run this generator, returning a flag indicating whether the generator is finished. If the
    /// flag is true, the generator will never be run again, otherwise it will be queued for another
    /// run next time a target in its watch list is populated.
    fn run(&self, witness: &PartitionWitness<F>, out_buffer: &mut GeneratedValues<F>) -> bool;
}

/// A wrapper around an `Box<WitnessGenerator>` which implements `PartialEq`
/// and `Eq` based on generator IDs.
pub struct WitnessGeneratorRef<F: PrimeField + ExtensionField<F>, const D: usize>(
    pub Box<dyn WitnessGenerator<F, D>>,
);

impl<F: PrimeField + ExtensionField<F>, const D: usize> WitnessGeneratorRef<F, D> {
    pub fn new<G: WitnessGenerator<F, D>>(generator: G) -> WitnessGeneratorRef<F, D> {
        WitnessGeneratorRef(Box::new(generator))
    }
}

impl<F: PrimeField + ExtensionField<F>, const D: usize> PartialEq for WitnessGeneratorRef<F, D> {
    fn eq(&self, other: &Self) -> bool {
        self.0.id() == other.0.id()
    }
}

impl<F: PrimeField + ExtensionField<F>, const D: usize> Eq for WitnessGeneratorRef<F, D> {}

impl<F: PrimeField + ExtensionField<F>, const D: usize> Debug for WitnessGeneratorRef<F, D> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.0.id())
    }
}

/// Values generated by a generator invocation.
#[derive(Debug)]
pub struct GeneratedValues<F: Field> {
    pub target_values: Vec<(Target, F)>,
}

impl<F: PrimeField> From<Vec<(Target, F)>> for GeneratedValues<F> {
    fn from(target_values: Vec<(Target, F)>) -> Self {
        Self { target_values }
    }
}

impl<F: PrimeField> WitnessWrite<F> for GeneratedValues<F> {
    fn set_target(&mut self, target: Target, value: F) {
        self.target_values.push((target, value));
    }
}

impl<F: PrimeField> GeneratedValues<F> {
    pub fn with_capacity(capacity: usize) -> Self {
        Vec::with_capacity(capacity).into()
    }

    pub fn empty() -> Self {
        Vec::new().into()
    }

    pub fn singleton_wire(wire: Wire, value: F) -> Self {
        Self::singleton_target(Target::Wire(wire), value)
    }

    pub fn singleton_target(target: Target, value: F) -> Self {
        vec![(target, value)].into()
    }

    // pub fn singleton_extension_target<const D: usize>(
    //     et: ExtensionTarget<D>,
    //     value: F::Extension,
    // ) -> Self
    //     where
    //         F: PrimeField + ExtensionField<F>,
    // {
    //     let mut witness = Self::with_capacity(D);
    //     witness.set_extension_target(et, value);
    //     witness
    // }
}

pub trait WitnessWrite<F: PrimeField + ExtensionField<F>> {
    fn set_target(&mut self, target: Target, value: F);

    // fn set_hash_target(&mut self, ht: HashOutTarget, value: HashOut<F>) {
    //     ht.elements
    //         .iter()
    //         .zip(value.elements)
    //         .for_each(|(&t, x)| self.set_target(t, x));
    // }

    // fn set_extension_target<const D: usize>(&mut self, et: ExtensionTarget<D>, value: F::Extension)
    //     where
    //         F: PrimeField + ExtensionField<F>,
    // {
    //     self.set_target_arr(&et.0, &value.to_basefield_array());
    // }

    fn set_target_arr(&mut self, targets: &[Target], values: &[F]) {
        zip_eq(targets, values).for_each(|(&target, &value)| self.set_target(target, value));
    }

    // fn set_extension_targets<const D: usize>(
    //     &mut self,
    //     ets: &[ExtensionTarget<D>],
    //     values: &[F::Extension],
    // ) where
    //     F: PrimeField + ExtensionField<F>,
    // {
    //     debug_assert_eq!(ets.len(), values.len());
    //     ets.iter()
    //         .zip(values)
    //         .for_each(|(&et, &v)| self.set_extension_target(et, v));
    // }

    // fn set_bool_target(&mut self, target: BoolTarget, value: bool) {
    //     self.set_target(target.target, F::from_bool(value))
    // }

    fn set_wire(&mut self, wire: Wire, value: F) {
        self.set_target(Target::Wire(wire), value)
    }

    fn set_wires<W>(&mut self, wires: W, values: &[F])
        where
            W: IntoIterator<Item = Wire>,
    {
        // If we used itertools, we could use zip_eq for extra safety.
        for (wire, &value) in wires.into_iter().zip(values) {
            self.set_wire(wire, value);
        }
    }

    // fn set_ext_wires<W, const D: usize>(&mut self, wires: W, value: F::Extension)
    //     where
    //         F: PrimeField + ExtensionField<F>,
    //         W: IntoIterator<Item = Wire>,
    // {
    //     self.set_wires(wires, &value.to_basefield_array());
    // }

    fn extend<I: Iterator<Item = (Target, F)>>(&mut self, pairs: I) {
        for (t, v) in pairs {
            self.set_target(t, v);
        }
    }
}

/// A witness holds information on the values of targets in a circuit.
pub trait Witness<F: PrimeField>: WitnessWrite<F> {
    fn try_get_target(&self, target: Target) -> Option<F>;

    fn get_target(&self, target: Target) -> F {
        self.try_get_target(target).unwrap()
    }

    fn get_targets(&self, targets: &[Target]) -> Vec<F> {
        targets.iter().map(|&t| self.get_target(t)).collect()
    }

    fn get_wire(&self, wire: Wire) -> F {
        self.get_target(Target::Wire(wire))
    }

    fn try_get_wire(&self, wire: Wire) -> Option<F> {
        self.try_get_target(Target::Wire(wire))
    }

    fn contains(&self, target: Target) -> bool {
        self.try_get_target(target).is_some()
    }

    fn contains_all(&self, targets: &[Target]) -> bool {
        targets.iter().all(|&t| self.contains(t))
    }
}

/// `PartitionWitness` holds a disjoint-set forest of the targets respecting a circuit's copy constraints.
/// The value of a target is defined to be the value of its root in the forest.
#[derive(Clone)]
pub struct PartitionWitness<'a, F: PrimeField> {
    pub values: Vec<Option<F>>,
    pub representative_map: &'a [usize],
    pub num_wires: usize,
    pub degree: usize,
}

impl<'a, F: PrimeField> PartitionWitness<'a, F> {
    pub fn new(num_wires: usize, degree: usize, representative_map: &'a [usize]) -> Self {
        Self {
            values: vec![None; representative_map.len()],
            representative_map,
            num_wires,
            degree,
        }
    }

    /// Set a `Target`. On success, returns the representative index of the newly-set target. If the
    /// target was already set, returns `None`.
    pub fn set_target_returning_rep(&mut self, target: Target, value: F) -> Option<usize> {
        let rep_index = self.representative_map[self.target_index(target)];
        let rep_value = &mut self.values[rep_index];
        if let Some(old_value) = *rep_value {
            assert_eq!(
                value, old_value,
                "Partition containing {:?} was set twice with different values: {} != {}",
                target, old_value, value
            );
            None
        } else {
            *rep_value = Some(value);
            Some(rep_index)
        }
    }

    pub(crate) fn target_index(&self, target: Target) -> usize {
        target.index(self.num_wires, self.degree)
    }

    pub fn full_witness(self) -> MatrixWitness<F> {
        let mut wire_values = vec![vec![F::zero(); self.degree]; self.num_wires];
        for i in 0..self.degree {
            for j in 0..self.num_wires {
                let t = Target::Wire(Wire { row: i, column: j });
                if let Some(x) = self.try_get_target(t) {
                    wire_values[j][i] = x;
                }
            }
        }

        MatrixWitness { wire_values }
    }
}

impl<'a, F: PrimeField> WitnessWrite<F> for PartitionWitness<'a, F> {
    fn set_target(&mut self, target: Target, value: F) {
        self.set_target_returning_rep(target, value);
    }
}

impl<'a, F: PrimeField> Witness<F> for PartitionWitness<'a, F> {
    fn try_get_target(&self, target: Target) -> Option<F> {
        let rep_index = self.representative_map[self.target_index(target)];
        self.values[rep_index]
    }
}

#[derive(Clone, Debug)]
pub struct MatrixWitness<F: Field> {
    pub(crate) wire_values: Vec<Vec<F>>,
}

impl<F: Field> MatrixWitness<F> {
    pub fn get_wire(&self, gate: usize, input: usize) -> F {
        self.wire_values[input][gate]
    }
}


#[derive(Clone, Debug, Default)]
pub struct ArithmeticBaseGenerator<F: PrimeField + ExtensionField<F>, const D: usize> {
    pub row: usize,
    pub const_0: F,
    pub const_1: F,
    pub i: usize,
}

impl<F: PrimeField + ExtensionField<F>, const D: usize> SimpleGenerator<F, D>
for ArithmeticBaseGenerator<F, D>
{
    fn id(&self) -> String {
        "ArithmeticBaseGenerator".to_string()
    }

    fn dependencies(&self) -> Vec<Target> {
        [
            ArithmeticGate::wire_ith_multiplicand_0(self.i),
            ArithmeticGate::wire_ith_multiplicand_1(self.i),
            ArithmeticGate::wire_ith_addend(self.i),
        ]
            .iter()
            .map(|&i| Target::wire(self.row, i))
            .collect()
    }

    fn run_once(&self, witness: &PartitionWitness<F>, out_buffer: &mut GeneratedValues<F>) {
        let get_wire = |wire: usize| -> F { witness.get_target(Target::wire(self.row, wire)) };

        let multiplicand_0 = get_wire(ArithmeticGate::wire_ith_multiplicand_0(self.i));
        let multiplicand_1 = get_wire(ArithmeticGate::wire_ith_multiplicand_1(self.i));
        let addend = get_wire(ArithmeticGate::wire_ith_addend(self.i));

        let output_target = Target::wire(self.row, ArithmeticGate::wire_ith_output(self.i));

        let computed_output =
            multiplicand_0 * multiplicand_1 * self.const_0 + addend * self.const_1;

        out_buffer.set_target(output_target, computed_output)
    }
}

/// A generator which runs once after a list of dependencies is present in the witness.
pub trait SimpleGenerator<F: PrimeField + ExtensionField<F>, const D: usize>:
'static + Send + Sync + Debug
{
    fn id(&self) -> String;

    fn dependencies(&self) -> Vec<Target>;

    fn run_once(&self, witness: &PartitionWitness<F>, out_buffer: &mut GeneratedValues<F>);

    fn adapter(self) -> SimpleGeneratorAdapter<F, Self, D>
        where
            Self: Sized,
    {
        SimpleGeneratorAdapter {
            inner: self,
            _phantom: PhantomData,
        }
    }
}

#[derive(Debug)]
pub struct SimpleGeneratorAdapter<
    F: PrimeField + ExtensionField<F>,
    SG: SimpleGenerator<F, D> + ?Sized,
    const D: usize,
> {
    _phantom: PhantomData<F>,
    inner: SG,
}

impl<F: PrimeField + ExtensionField<F>, SG: SimpleGenerator<F, D>, const D: usize> WitnessGenerator<F, D>
for SimpleGeneratorAdapter<F, SG, D>
{
    fn id(&self) -> String {
        self.inner.id()
    }

    fn watch_list(&self) -> Vec<Target> {
        self.inner.dependencies()
    }

    fn run(&self, witness: &PartitionWitness<F>, out_buffer: &mut GeneratedValues<F>) -> bool {
        if witness.contains_all(&self.inner.dependencies()) {
            self.inner.run_once(witness, out_buffer);
            true
        } else {
            false
        }
    }
}

#[derive(Clone, Debug, Default)]
pub struct PartialWitness<F: Field> {
    pub target_values: HashMap<Target, F>,
}

impl<F: Field> PartialWitness<F> {
    pub fn new() -> Self {
        Self {
            target_values: HashMap::new(),
        }
    }
}

impl<F: PrimeField> WitnessWrite<F> for PartialWitness<F> {
    fn set_target(&mut self, target: Target, value: F) {
        let opt_old_value = self.target_values.insert(target, value);
        if let Some(old_value) = opt_old_value {
            assert_eq!(
                value, old_value,
                "Target {:?} was set twice with different values: {} != {}",
                target, old_value, value
            );
        }
    }
}

impl<F: PrimeField> Witness<F> for PartialWitness<F> {
    fn try_get_target(&self, target: Target) -> Option<F> {
        self.target_values.get(&target).copied()
    }
}